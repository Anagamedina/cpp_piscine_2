# ๐จ DIAGRAMA VISUAL - Sobrecargas de iter

## ๐ Concepto Principal

```
HAY 2 TIPOS DE FUNCIONES EN C++:
โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ

Tipo 1: Funciones que SOLO LEEN (const)
        โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ
        void f(T const & x) {
            std::cout << x;  // Solo lee
        }

Tipo 2: Funciones que MODIFICAN (non-const)
        โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ
        void f(T& x) {
            x++;  // Modifica
        }


PROBLEMA: iter debe funcionar con AMBOS tipos
SOLUCIรN: Hacer 2 sobrecargas (una para cada tipo)
```

---

## ๐ Visualizaciรณn del Problema

```
TENEMOS ESTAS FUNCIONES:
โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ

โโโโโโโโโโโโโโโโโโโโโโโโโโโโ        โโโโโโโโโโโโโโโโโโโโโโโโโโโโ
โ void mostrar(int const &)โ        โ void incrementar(int&)   โ
โ {                        โ        โ {                        โ
โ   cout << x;             โ        โ   x++;                   โ
โ }                        โ        โ }                        โ
โ                          โ        โ                          โ
โ TIPO: const &            โ        โ TIPO: & (non-const)      โ
โโโโโโโโโโโโโโโโโโโโโโโโโโโโ        โโโโโโโโโโโโโโโโโโโโโโโโโโโโ


SI SOLO TUVIรRAMOS UNA VERSIรN DE ITER:
โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ

void iter(T* arr, size_t len, void (*f)(T const &)) {
    // Solo acepta funciones const
}

int nums[] = {1, 2, 3};

iter(nums, 3, mostrar);      // โ FUNCIONA
                             // mostrar ES const

iter(nums, 3, incrementar);  // โ ERROR
                             // incrementar NO es const
                             // Es T&, no T const &
```

---

## โ Soluciรณn: Dos Sobrecargas

```
SOBRECARGA 1                           SOBRECARGA 2
(para funciones const)                 (para funciones non-const)
โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ       โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ

void iter(                             void iter(
    T* array,                              T* array,
    size_t length,                         size_t length,
    void (*function)(T const &)            void (*function)(T&)
) {                                    ) {
    for (i...) {                           for (i...) {
        function(array[i]);                    function(array[i]);
    }                                      }
}                                      }

ACEPTA:                                ACEPTA:
โข mostrar(T const &)                   โข incrementar(T&)
โข imprimir(T const &)                  โข duplicar(T&)
โข comparar(T const &)                  โข modificar(T&)
```

---

## ๐ Proceso de Selecciรณn

```
CUANDO LLAMAS A iter:
โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ

int nums[] = {1, 2, 3};

LLAMADA 1:
โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ
iter(nums, 3, mostrar);

1. Compilador ve: mostrar tiene firma void(int const &)
2. Busca iter que acepte: void(*)(int const &)
3. Encuentra: SOBRECARGA 1 โ
4. Usa esa versiรณn


LLAMADA 2:
โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ
iter(nums, 3, incrementar);

1. Compilador ve: incrementar tiene firma void(int&)
2. Busca iter que acepte: void(*)(int&)
3. Encuentra: SOBRECARGA 2 โ
4. Usa esa versiรณn
```

---

## ๐ ยฟPor quรฉ el `*` (puntero)?

```
ANALOGรA:
โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ

int x = 42;           // x es un int
int* p = &x;          // p es un PUNTERO a int
                      // p guarda la DIRECCIรN de x

void mostrar(int x);  // mostrar es una FUNCIรN
void (*f)(int);       // f es un PUNTERO a funciรณn
f = mostrar;          // f guarda la DIRECCIรN de mostrar


VISUALIZACIรN:
โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ

MEMORIA:
โโโโโโโโโโโโโโโโโโโโโโโโ
โ Funciรณn: mostrar     โ
โ Direcciรณn: 0x1000    โ โ La funciรณn estรก aquรญ
โ Cรณdigo: { cout... }  โ
โโโโโโโโโโโโโโโโโโโโโโโโ
         โ
         โ (apunta)
         โ
โโโโโโโโโโโโโโโโโโโโโโโโ
โ f (puntero)          โ
โ Valor: 0x1000        โ โ f guarda la direcciรณn
โโโโโโโโโโโโโโโโโโโโโโโโ


USO:
f(42);  โ  Busca direcciรณn (0x1000)
        โ  Ejecuta funciรณn en 0x1000
        โ  Llama a mostrar(42)
```

---

## ๐ฏ Ejemplo Completo con Flujo

```cpp
// โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ
// DEFINICIONES
// โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ

void mostrar(int const & x) {
    std::cout << x << " ";
}

void duplicar(int& x) {
    x *= 2;
}

// โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ
// MAIN
// โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ

int main() {
    int nums[] = {1, 2, 3};
    
    // ANTES:
    std::cout << "Antes: ";
    iter(nums, 3, mostrar);
    // Output: "Antes: 1 2 3 "
    
    // MODIFICAR:
    iter(nums, 3, duplicar);
    
    // DESPUรS:
    std::cout << "Despuรฉs: ";
    iter(nums, 3, mostrar);
    // Output: "Despuรฉs: 2 4 6 "
}
```

### Flujo Detallado:

```
PASO 1: iter(nums, 3, mostrar)
โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ

Compilador selecciona:
โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ
โ void iter(T*, size_t, void (*)(T const &))  โ โ Esta
โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ

Porque:
mostrar tiene firma: void(int const &)
Coincide con: void (*)(T const &)

Ejecuta:
i=0: mostrar(nums[0]) โ imprime "1 "
i=1: mostrar(nums[1]) โ imprime "2 "
i=2: mostrar(nums[2]) โ imprime "3 "

Array sigue igual: [1, 2, 3]


PASO 2: iter(nums, 3, duplicar)
โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ

Compilador selecciona:
โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ
โ void iter(T*, size_t, void (*)(T&))         โ โ Esta
โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ

Porque:
duplicar tiene firma: void(int&)
Coincide con: void (*)(T&)

Ejecuta:
i=0: duplicar(nums[0]) โ nums[0] = 1*2 = 2
i=1: duplicar(nums[1]) โ nums[1] = 2*2 = 4
i=2: duplicar(nums[2]) โ nums[2] = 3*2 = 6

Array cambia: [2, 4, 6]


PASO 3: iter(nums, 3, mostrar) de nuevo
โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ

Usa misma sobrecarga que PASO 1

Ejecuta:
i=0: mostrar(nums[0]) โ imprime "2 "
i=1: mostrar(nums[1]) โ imprime "4 "
i=2: mostrar(nums[2]) โ imprime "6 "

Array sigue: [2, 4, 6]
```

---

## ๐ Diferencia const vs non-const VISUALIZADA

```
FUNCIรN CON const &:
โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ

void mostrar(int const & x) {
    std::cout << x;     // โ OK: solo lee
    // x = 10;          // โ ERROR: no puede modificar
    // x++;             // โ ERROR: no puede modificar
}

int nums[] = {1, 2, 3};
mostrar(nums[0]);

ANTES:  nums[0] = 1
LLAMA:  mostrar(nums[0])
DESPUรS: nums[0] = 1  โ NO CAMBIA


FUNCIรN SIN const (solo &):
โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ

void duplicar(int& x) {
    x = x * 2;          // โ OK: puede modificar
    x++;                // โ OK: puede modificar
}

int nums[] = {1, 2, 3};
duplicar(nums[0]);

ANTES:  nums[0] = 1
LLAMA:  duplicar(nums[0])
DESPUรS: nums[0] = 2  โ ยกCAMBIA!
```

---

## ๐ก Tabla Resumen Final

```
โโโโโโโโโโโโโโโโโโโโโโฆโโโโโโโโโโโโโโโโโโโโโโโฆโโโโโโโโโโโโโโโโโโโโโโโ
โ   CONCEPTO         โ   const &            โ   & (non-const)      โ
โโโโโโโโโโโโโโโโโโโโโโฌโโโโโโโโโโโโโโโโโโโโโโโฌโโโโโโโโโโโโโโโโโโโโโโโฃ
โ                    โ                      โ                      โ
โ Sintaxis           โ void f(T const & x)  โ void f(T& x)         โ
โ                    โ                      โ                      โ
โโโโโโโโโโโโโโโโโโโโโโฌโโโโโโโโโโโโโโโโโโโโโโโฌโโโโโโโโโโโโโโโโโโโโโโโฃ
โ                    โ                      โ                      โ
โ ยฟPuede modificar?  โ โ NO                โ โ Sร                โ
โ                    โ                      โ                      โ
โโโโโโโโโโโโโโโโโโโโโโฌโโโโโโโโโโโโโโโโโโโโโโโฌโโโโโโโโโโโโโโโโโโโโโโโฃ
โ                    โ                      โ                      โ
โ Ejemplos           โ mostrar, imprimir,   โ incrementar,         โ
โ                    โ comparar, buscar     โ duplicar, modificar  โ
โ                    โ                      โ                      โ
โโโโโโโโโโโโโโโโโโโโโโฌโโโโโโโโโโโโโโโโโโโโโโโฌโโโโโโโโโโโโโโโโโโโโโโโฃ
โ                    โ                      โ                      โ
โ Sobrecarga iter    โ void (*)(T const &)  โ void (*)(T&)         โ
โ que acepta         โ                      โ                      โ
โ                    โ                      โ                      โ
โโโโโโโโโโโโโโโโโโโโโโฉโโโโโโโโโโโโโโโโโโโโโโโฉโโโโโโโโโโโโโโโโโโโโโโโ
```

---

## ๐ Mini-Test

```cpp
// ยฟQuรฉ sobrecarga se usa en cada caso?

int nums[] = {1, 2, 3};

// 1.
void print(int const & x) { std::cout << x; }
iter(nums, 3, print);
// Respuesta: Sobrecarga const (void (*)(T const &))

// 2.
void triple(int& x) { x *= 3; }
iter(nums, 3, triple);
// Respuesta: Sobrecarga non-const (void (*)(T&))

// 3.
void show(int const & x) { std::cout << x; }
iter(nums, 3, show);
// Respuesta: Sobrecarga const (void (*)(T const &))

// 4.
void add10(int& x) { x += 10; }
iter(nums, 3, add10);
// Respuesta: Sobrecarga non-const (void (*)(T&))
```

---

## ๐ฏ Conclusiรณn Simple

```
โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ
โ                  RESUMEN ULTRA-SIMPLE                    โ
โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโค
โ                                                          โ
โ  1. (*) = PUNTERO                                        โ
โ     void (*f)(...) = puntero a funciรณn                   โ
โ                                                          โ
โ  2. DOS SOBRECARGAS                                      โ
โ     โข Una para funciones const (solo leen)               โ
โ     โข Otra para funciones non-const (modifican)          โ
โ                                                          โ
โ  3. DIFERENCIA                                           โ
โ     โข const & โ NO modifica                              โ
โ     โข & โ Sร modifica                                    โ
โ                                                          โ
โ  El compilador AUTOMรTICAMENTE elige la correcta         โ
โ  segรบn el tipo de funciรณn que pases                      โ
โ                                                          โ
โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ
```

---

**ยกAhora deberรญas entender completamente las sobrecargas!** ๐












